一、树的种类
1.满二叉树
2.完全二叉树（优先左边补满）
3.二叉搜索树、二叉查找树、有序二叉树或者排序二叉树（左小右大）
4.平衡二叉树（叶节点高度差不超过1）

二、存储结构：
1.顺序存储（从上至下，从左至右），数组存储
2.链式存储（节点存储TreeNode）

三、遍历：(主要分为DFS和BFS，方法有递归、回溯、栈、队列，本质都是遍历的同时进行一些操作以达到目的）
1.深度优先（递归 栈）
1.1前序 根左右  144 简单，不用过
1.2中序 左根右  94 简单，不用过
1.3后序 左右根  145 中等
迭代可以写一下(双栈：第二个栈还原成后序；单栈：右边没了或者遍历完了就添加根节点）以上三题递归套路都一样

2.广度优先（队列） 102 103
BFS:记录每一层的数量（可用于层序遍历和最短路径问题） 中等

3、求深度：
3.1最大深度 DFS BFS 104 简单
3.2最小深度 DFS(搞清楚递归结束条件) BFS(子节点为空就返回) 111 中等

4、二叉树中的最大路径和 DFS 困难 124

5.对称二叉树 101 简单
递归比较左右子树
队列 修改放入顺序

6.路径总和 112/113 中等
递归、回溯（左右都回溯一遍，然后回到之前的结果）、栈（保留计算的中间值，一起入栈）、队列
记录中间结果时需要再new Arraylist，否则添加的是最终结果的引用地址；

7.二叉树的最近公共祖先 236 中等
递归（成员变量存储最终结果，不用原函数）
哈希表存储所有节点的父节点，然后p,q往上遍历

8.二叉树的右视图 199 中等
使用深度来标记 BFS 队列/DFS 递归

9.翻转二叉树 226 简单

10.二叉树的完全性检验 958 中等
深度做标记  层序遍历更优

11.另一棵树的子树 572 中等
递归 DFS

12.相同的树 100 简单

13.二叉树的序列化与反序列化 297 困难
BFS
DFS

14.二叉树展开为链表 114困难
递归，由繁化简，左子树的尾节点接到右子树，找到递归终止条件  可以看最新的提交
先前序遍历然后还原；迭代 递归
前序和还原同时进行；迭代 递归
后序遍历自底向上：迭代 递归

四、还原
1.从前序与中序遍历序列构造二叉树 105

ArrayDeque
poll=pop从顶端推出
push从顶端添加
add从尾端添加
offer从尾端添加