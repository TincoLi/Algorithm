一、树的种类
1.满二叉树
2.完全二叉树（优先左边补满）
3.二叉搜索树、二叉查找树、有序二叉树或者排序二叉树（左小右大）
4.平衡二叉树（叶节点高度差不超过1）

二、存储结构：
1.顺序存储（从上至下，从左至右），数组存储
2.链式存储（节点存储TreeNode）

三、遍历：(主要分为DFS和BFS，方法有递归、回溯、栈、队列，本质都是遍历的同时进行一些操作以达到目的）
1.深度优先（递归 栈）
1.1前序 根左右  144 简单，不用过
1.2中序 左根右  94 简单，不用过
1.3后序 左右根  145 中等
迭代可以写一下(双栈：第二个栈还原成后序；单栈：右边没了或者遍历完了就添加根节点）以上三题递归套路都一样
2.广度优先（队列） 102 103
BFS:记录每一层的数量（可用于层序遍历和最短路径问题） 中等
3、求深度：
3.1最大深度 DFS BFS 104 简单
3.2最小深度 DFS(搞清楚递归结束条件) BFS(子节点为空就返回) 111 中等
4、二叉树中的最大路径和 DFS 困难 124
5.对称二叉树 101 简单
递归比较左右子树
队列 修改放入顺序
6.路径总和 112/113 中等
递归、回溯（左右都回溯一遍，然后回到之前的结果）、栈（保留计算的中间值，一起入栈）、队列
记录中间结果时需要再new Arraylist，否则添加的是最终结果的引用地址；
7.二叉树的最近公共祖先 236 中等
递归（成员变量存储最终结果，不用原函数）
哈希表存储所有节点的父节点，然后p,q往上遍历
8.二叉树的右视图 199 中等
使用深度来标记 BFS 队列/DFS 递归
9.翻转二叉树 226 简单
10.二叉树的完全性检验 958 中等
深度做标记  层序遍历更优
11.另一棵树的子树 572 中等 递归 DFS
12.相同的树 100 简单
13.二叉树的序列化与反序列化 297 困难BFSDFS
14.二叉树展开为链表 114困难
递归，由繁化简，左子树的尾节点接到右子树，找到递归终止条件  可以看最新的提交
先前序遍历然后还原；迭代 递归
前序和还原同时进行；迭代 递归
后序遍历自底向上：迭代 递归

四、还原
1.从前序与中序遍历序列构造二叉树 105 中等
2.从中序与后序遍历序列构造二叉树 106 中等
递归：使用一个标志位替代Hashmap
迭代：遍历前序遍历的数组，一直作为当前根节点的左子树，直到当前节点和中序遍历的数组的节点相等了，
那么我们正序遍历中序遍历的数组，倒着遍历已经遍历过的根节点（用栈的 pop 实现），找到最后一次相等的位置，把它作为该节点的右子树。
规律：左子树中序遍历的正序是前序遍历的倒序

五、二叉搜索树题目 #
题号	标题	题解	标签	难度
1.0098	验证二叉搜索树	Python	树、深度优先搜索、递归	中等
先找一下是否三种遍历的规律，再想DFS BFS
2.0450	删除二叉搜索树中的节点	Python	树	中等
3.剑指 Offer 54	二叉搜索树的第k大节点	Python	树、深度优先搜索、二叉搜索树、二叉树	简单
4.0230	二叉搜索树中第K小的元素			中等
如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化算法？
方法三需要先掌握 平衡二叉搜索树（AVL树） 的知识。平衡二叉搜索树具有如下性质：
平衡二叉搜索树中每个结点的左子树和右子树的高度最多相差 1；
平衡二叉搜索树的子树也是平衡二叉搜索树；
一棵存有 n 个结点的平衡二叉搜索树的高度是 O(logn)。
https://blog.csdn.net/weixin_45902285/article/details/124517412
5.0426	将二叉搜索树转化为排序的双向链表	Python	栈、树、深度优先搜索、二叉搜索树、链表、二叉树、双向链表	BFS/DFS 简单
6.0110	平衡二叉树	Python	树、深度优先搜索、递归	简单

六、并查集题目 #
题号	标题	题解	标签	难度
0128	最长连续序列	Python	并查集、数组、哈希表	中等


ArrayDeque
poll=pop从顶端推出
push从顶端添加
add从尾端添加
offer从尾端添加

堆的特点：
完全二叉树
左子树 2*i+1
右子树 2*i+2
建堆开始调整的节点 2*i+1 = num.length --> i = (nums.length-1)/2;
建堆后每次将最大值交换到最后，然后前面节点重新调整